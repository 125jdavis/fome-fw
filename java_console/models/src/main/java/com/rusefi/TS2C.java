package com.rusefi;

import com.opensr5.ini.IniFileModel;
import com.opensr5.ini.field.ArrayIniField;

import java.io.*;
import java.util.Arrays;
import java.util.Date;

/**
 * tuner studio project to C data structure converter command line utility
 * <p>
 * 12/27/2014
 * Andrey Belomutskiy, (c) 2012-2016
 */
@SuppressWarnings("StringConcatenationInsideStringBufferAppend")
public class TS2C {
    // todo: replace with loadCount & rpmCount
    private final int size;

    private float[] loadBins;
    private float[] rpmBins;

    /**
     * @see TS2CRunner
     */
    public static void main(String[] args) throws IOException {
        new TS2C(args);
    }

    private TS2C(String[] args) throws IOException {
        System.out.println("This tool reads TS tune file and produces some C code for hardcoded base tunes");
        if (args.length != 4 && args.length != 5) {
            System.out.println("Four parameters expected: ");
            System.out.println("  INPUT_MSQ_FILE NAME LOAD_SECTION_NAME RPM_SECTION_NAME TABLE_NAME");
            System.out.println("for example");
            // section names are needed in order to generate comments about cell content
            System.out.println("  currenttune.msq veLoadBins veRpmBins veTable");
            System.exit(-1);
        }
        String msqFileName = args[0];
        String loadSectionName = args[1];
        String rpmSectionName = args[2];
        String tableName = args[3];
        size = Integer.parseInt(args.length > 4 ? args[4] : "16");

        IniFileModel model = IniFileModel.getInstance();

        BufferedWriter w = new BufferedWriter(new FileWriter("generated_" + tableName + ".cpp"));

        if (!loadSectionName.equalsIgnoreCase("none")) {
            loadBins = processCurve(msqFileName, loadSectionName, model, w);
        }

        if (!rpmSectionName.equalsIgnoreCase("none")) {
            rpmBins = processCurve(msqFileName, rpmSectionName, model, w);
        }

        if (!tableName.equalsIgnoreCase("none")) {
            float[][] table;

            table = new float[size][];
            for (int i = 0; i < size; i++) {
                table[i] = new float[size];
            }

            BufferedReader r = readAndScroll(msqFileName, tableName);
            readTable(table, r);

            writeTable(w, (loadIndex, rpmIndex) -> table[loadIndex][rpmIndex], "TS2C");
            w.write("\r\n\r\n");
        }

        w.write("static void set" + tableName + "() {\n");
        w.write("\tMEMCPY(config->" + rpmSectionName + ", hardCoded" + rpmSectionName + ");\n");

        if (!tableName.equalsIgnoreCase("none")) {

        }


        w.write("}\n");

        w.close();
    }

    private float[] processCurve(String msqFileName, String loadSectionName, IniFileModel model, BufferedWriter w) throws IOException {
        ArrayIniField field = (ArrayIniField) model.allIniFields.get(loadSectionName);
        int curveSize = field.getRows();
        BufferedReader r = readAndScroll(msqFileName, loadSectionName);
        float[] curve = new float[curveSize];
        readAxle(curve, r);

        w.write("static const float hardCoded" + loadSectionName + "[" + curveSize + "] = ");
        w.write(toString(curve));
        w.write(";\r\n\r\n");
        return curve;
    }

    private String toString(float[] a) {
        StringBuilder b = new StringBuilder();
        int iMax = a.length - 1;
        b.append('{');
        for (int i = 0; ; i++) {
            b.append(a[i]);
            if (i == iMax)
                return b.append('}').toString();
            b.append(", ");
        }
    }

    private void writeTable(BufferedWriter w, ValueSource valueSource, String toolName) throws IOException {
        w.write("/* Generated by " + toolName + " on " + new Date() + "*/\r\n");
        for (int loadIndex = 0; loadIndex < loadBins.length; loadIndex++)
            writeTableLine(valueSource, w, loadIndex);
    }

    /**
     * @param fileName       text file to open
     * @param magicStringKey magic string content to scroll to
     * @return Reader after the magicStringKey line
     */
    private static BufferedReader readAndScroll(String fileName, String magicStringKey) throws IOException {
        BufferedReader reader = new BufferedReader(new FileReader(fileName));
        System.out.println("Reading from " + fileName + ", scrolling to " + magicStringKey);
        String line;
        while ((line = reader.readLine()) != null) {
            if (line.contains(magicStringKey)) {
                System.out.println("Found " + line);
                break;
            }
        }
        return reader;
    }

    private void writeTableLine(ValueSource valueSource, BufferedWriter w, int loadIndex) throws IOException {
        StringBuilder sb = new StringBuilder("{");

        sb.append("/* " + loadIndex + " " + String.format("%3.3f", loadBins[loadIndex]) + "\t*/");
        for (int rpmIndex = 0; rpmIndex < rpmBins.length; rpmIndex++) {
            sb.append("/* " + rpmIndex + " " + rpmBins[rpmIndex] + "*/" + String.format("%3.3f", valueSource.getValue(loadIndex, rpmIndex)) + ",\t");
        }
        sb.append("},\r\n");

        w.write(sb.toString());
    }

    interface ValueSource {
        float getValue(int loadIndex, int rpmIndex);
    }

    private void readTable(float[][] table, BufferedReader r) throws IOException {
        int index = 0;

        while (index < size) {
            String line = r.readLine();
            if (line == null)
                throw new IOException("End of file?");
            line = line.trim();
            if (line.isEmpty())
                continue;

            String[] values = line.split("\\s");
            if (values.length != size)
                throw new IllegalStateException("Expected " + size + " but got " + Arrays.toString(values) + ". Unexpected line: " + line);

            for (int i = 0; i < size; i++) {
                String str = values[i];
                try {
                    table[index][i] = Float.parseFloat(str);
                } catch (NumberFormatException e) {
                    throw new IllegalStateException("While reading " + str, e);
                }
            }
            System.out.println("Got line " + index + ": " + Arrays.toString(table[index]));
            index++;
        }
    }

    private void readAxle(float[] bins, BufferedReader r) throws IOException {
        int index = 0;

        while (index < size) {
            String line = r.readLine();
            if (line == null)
                throw new IOException("End of file?");
            line = line.trim();
            if (line.isEmpty())
                continue;
            bins[index++] = Float.parseFloat(line);
        }

        System.out.println("Got bins " + Arrays.toString(bins));
    }
}
