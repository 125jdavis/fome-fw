diff -uwr ChibiOS-stable_rusefi/demos/STM32/RT-STM32F334R8-NUCLEO/mcuconf.h ChibiOS-stable_16.1.x/demos/STM32/RT-STM32F334R8-NUCLEO/mcuconf.h
--- ChibiOS-stable_rusefi/demos/STM32/RT-STM32F334R8-NUCLEO/mcuconf.h	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/demos/STM32/RT-STM32F334R8-NUCLEO/mcuconf.h	2017-04-25 11:16:44.000000000 +0300
@@ -67,7 +67,7 @@
 #define STM32_ADC_USE_ADC1                  FALSE
 #define STM32_ADC_USE_ADC2                  FALSE
 #define STM32_ADC_ADC1_DMA_STREAM           STM32_DMA_STREAM_ID(1, 1)
-#define STM32_ADC_ADC2_DMA_STREAM           STM32_DMA_STREAM_ID(1, 2)
+#define STM32_ADC_ADC2_DMA_STREAM           STM32_DMA_STREAM_ID(2, 1)
 #define STM32_ADC_ADC1_DMA_PRIORITY         2
 #define STM32_ADC_ADC2_DMA_PRIORITY         2
 #define STM32_ADC_ADC12_IRQ_PRIORITY        5
diff -uwr ChibiOS-stable_rusefi/os/common/ports/ARMCMx/compilers/GCC/rules.mk ChibiOS-stable_16.1.x/os/common/ports/ARMCMx/compilers/GCC/rules.mk
--- ChibiOS-stable_rusefi/os/common/ports/ARMCMx/compilers/GCC/rules.mk	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/os/common/ports/ARMCMx/compilers/GCC/rules.mk	2017-04-25 11:16:44.000000000 +0300
@@ -93,9 +93,8 @@
 TCOBJS    := $(addprefix $(OBJDIR)/, $(notdir $(TCSRC:.c=.o)))
 TCPPOBJS  := $(addprefix $(OBJDIR)/, $(notdir $(TCPPSRC:.cpp=.o)))
 ASMOBJS   := $(addprefix $(OBJDIR)/, $(notdir $(ASMSRC:.s=.o)))
-#ASMXOBJS  := $(addprefix $(OBJDIR)/, $(notdir $(ASMXSRC:.S=.o)))
-#OBJS	  := $(ASMXOBJS) $(ASMOBJS) $(ACOBJS) $(TCOBJS) $(ACPPOBJS) $(TCPPOBJS)
-OBJS	  :=             $(ASMOBJS) $(ACOBJS) $(TCOBJS) $(ACPPOBJS) $(TCPPOBJS)
+ASMXOBJS  := $(addprefix $(OBJDIR)/, $(notdir $(ASMXSRC:.S=.o)))
+OBJS	  := $(ASMXOBJS) $(ASMOBJS) $(ACOBJS) $(TCOBJS) $(ACPPOBJS) $(TCPPOBJS)
 
 # Paths
 IINCDIR   := $(patsubst %,-I%,$(INCDIR) $(DINCDIR) $(UINCDIR))
@@ -227,14 +226,14 @@
 	@$(AS) -c $(ASFLAGS) -I. $(IINCDIR) $< -o $@
 endif
 
-#$(ASMXOBJS) : $(OBJDIR)/%.o : %.S Makefile
-#ifeq ($(USE_VERBOSE_COMPILE),yes)
-#	@echo
-#	$(CC) -c $(ASXFLAGS) $(TOPT) -I. $(IINCDIR) $< -o $@
-#else
-#	@echo Compiling $(<F)
-#	@$(CC) -c $(ASXFLAGS) $(TOPT) -I. $(IINCDIR) $< -o $@
-#endif
+$(ASMXOBJS) : $(OBJDIR)/%.o : %.S Makefile
+ifeq ($(USE_VERBOSE_COMPILE),yes)
+	@echo
+	$(CC) -c $(ASXFLAGS) $(TOPT) -I. $(IINCDIR) $< -o $@
+else
+	@echo Compiling $(<F)
+	@$(CC) -c $(ASXFLAGS) $(TOPT) -I. $(IINCDIR) $< -o $@
+endif
 
 $(BUILDDIR)/$(PROJECT).elf: $(OBJS) $(LDSCRIPT)
 ifeq ($(USE_VERBOSE_COMPILE),yes)
diff -uwr ChibiOS-stable_rusefi/os/common/ports/ARMCMx/compilers/GCC/vectors.c ChibiOS-stable_16.1.x/os/common/ports/ARMCMx/compilers/GCC/vectors.c
--- ChibiOS-stable_rusefi/os/common/ports/ARMCMx/compilers/GCC/vectors.c	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/os/common/ports/ARMCMx/compilers/GCC/vectors.c	2017-04-25 11:16:44.000000000 +0300
@@ -43,7 +43,6 @@
  * @notapi
  */
 /*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
-__attribute__((weak))
 void _unhandled_exception(void) {
 /*lint -restore*/
 
Only in ChibiOS-stable_rusefi/os/common: startup
diff -uwr ChibiOS-stable_rusefi/os/hal/include/uart.h ChibiOS-stable_16.1.x/os/hal/include/uart.h
--- ChibiOS-stable_rusefi/os/hal/include/uart.h	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/os/hal/include/uart.h	2017-04-25 11:16:44.000000000 +0300
@@ -185,23 +185,6 @@
 #define _uart_wakeup_rx_error_isr(uartp)
 #endif /* !UART_USE_WAIT */
 
-#if (UART_USE_WAIT == TRUE) || defined(__DOXYGEN__)
-/**
- * @brief   Wakes up the waiting thread in case of RX timeout.
- *
- * @param[in] uartp     pointer to the @p UARTDriver object
- *
- * @notapi
- */
-#define _uart_wakeup_rx_timeout_isr(uartp) {                                \
-  osalSysLockFromISR();                                                     \
-  osalThreadResumeI(&(uartp)->threadrx, MSG_TIMEOUT);                       \
-  osalSysUnlockFromISR();                                                   \
-}
-#else /* !UART_USE_WAIT */
-#define _uart_wakeup_rx_timeout_isr(uartp)
-#endif /* !UART_USE_WAIT */
-
 /**
  * @brief   Common ISR code for early TX.
  * @details This code handles the portable part of the ISR code:
@@ -275,27 +258,6 @@
 }
 
 /**
- * @brief   Common ISR code for RX half-transfer data.
- * @details This code handles the portable part of the ISR code:
- *          - Callback invocation.
- *          - Waiting thread wakeup, if any.
- *          - Driver state transitions.
- *          .
- * @note    This macro is meant to be used in the low level drivers
- *          implementation only.
- *
- * @param[in] uartp     pointer to the @p UARTDriver object
- * @param[in] full      flag set to 1 for the second half, and 0 for the first half
- *
- * @notapi
- */
-#define _uart_rx_half_isr_code(uartp, full) {                               \
-  if ((uartp)->config->rxhalf_cb != NULL)                                   \
-    (uartp)->config->rxhalf_cb(uartp, full);                                \
-}
-
-
-/**
  * @brief   Common ISR code for RX error.
  * @details This code handles the portable part of the ISR code:
  *          - Callback invocation.
@@ -317,6 +279,7 @@
   _uart_wakeup_rx_error_isr(uartp);                                         \
 }
 
+
 /**
  * @brief   Common ISR code for RX on idle.
  * @details This code handles the portable part of the ISR code:
@@ -335,28 +298,6 @@
   if ((uartp)->config->rxchar_cb != NULL)                                   \
     (uartp)->config->rxchar_cb(uartp, (uartp)->rxbuf);                      \
 }
-
-/**
- * @brief   Timeout ISR code for receiver.
- * @details This code handles the portable part of the ISR code:
- *          - Callback invocation.
- *          - Waiting thread wakeup, if any.
- *          - Driver state transitions.
- *          .
- * @note    This macro is meant to be used in the low level drivers
- *          implementation only.
- *
- * @param[in] uartp     pointer to the @p UARTDriver object
- *
- * @notapi
- */
-#define _uart_timeout_isr_code(uartp) {                                     \
-  if ((uartp)->config->timeout_cb != NULL) {                                \
-    (uartp)->config->timeout_cb(uartp);                                     \
-  }                                                                         \
-  _uart_wakeup_rx_timeout_isr(uartp);                                       \
-}
-
 /** @} */
 
 /*===========================================================================*/
diff -uwr ChibiOS-stable_rusefi/os/hal/lib/streams/chprintf.c ChibiOS-stable_16.1.x/os/hal/lib/streams/chprintf.c
--- ChibiOS-stable_rusefi/os/hal/lib/streams/chprintf.c	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/os/hal/lib/streams/chprintf.c	2017-04-25 11:16:44.000000000 +0300
@@ -32,9 +32,7 @@
 #include "memstreams.h"
 
 #define MAX_FILLER 11
-#define MAX_FLOAT_PRECISION 9
-#define DEFAULT_FLOAT_PRECISION 2
-
+#define FLOAT_PRECISION 9
 
 static char *long_to_string_with_divisor(char *p,
                                          long num,
@@ -75,22 +73,15 @@
 }
 
 #if CHPRINTF_USE_FLOAT
-static const long pow10[MAX_FLOAT_PRECISION] = {
+static const long pow10[FLOAT_PRECISION] = {
     10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000
 };
 
 static char *ftoa(char *p, double num, unsigned long precision) {
-  if (num < 0) {
-    *p++ = '-';
-    return ftoa(p, -num, precision);
-  }
   long l;
 
-  if (precision == 0) {
-    precision = DEFAULT_FLOAT_PRECISION;
-  } else if (precision > MAX_FLOAT_PRECISION) {
-    precision = MAX_FLOAT_PRECISION;
-  }
+  if ((precision == 0) || (precision > FLOAT_PRECISION))
+    precision = FLOAT_PRECISION;
   precision = pow10[precision - 1];
 
   l = (long)num;
@@ -140,7 +131,6 @@
   char tmpbuf[MAX_FILLER + 1];
 #endif
 
-
   while (true) {
     c = *fmt++;
     if (c == 0)
diff -uwr ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/I2Cv1/i2c_lld.c ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/I2Cv1/i2c_lld.c
--- ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/I2Cv1/i2c_lld.c	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/I2Cv1/i2c_lld.c	2017-04-25 11:16:44.000000000 +0300
@@ -537,9 +537,6 @@
 void i2c_lld_start(I2CDriver *i2cp) {
   I2C_TypeDef *dp = i2cp->i2c;
 
-  /* If in stopped state then enables the I2C and DMA clocks.*/
-  if (i2cp->state == I2C_STOP) {
-
     i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
                       STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                       STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
@@ -549,6 +546,9 @@
                       STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                       STM32_DMA_CR_DIR_P2M;
 
+  /* If in stopped state then enables the I2C and DMA clocks.*/
+  if (i2cp->state == I2C_STOP) {
+
 #if STM32_I2C_USE_I2C1
     if (&I2CD1 == i2cp) {
       bool b;
diff -uwr ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/I2Cv2/i2c_lld.c ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/I2Cv2/i2c_lld.c
--- ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/I2Cv2/i2c_lld.c	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/I2Cv2/i2c_lld.c	2017-04-25 11:16:44.000000000 +0300
@@ -672,18 +672,18 @@
 void i2c_lld_start(I2CDriver *i2cp) {
   I2C_TypeDef *dp = i2cp->i2c;
 
-  /* Make sure I2C peripheral is disabled */
-  dp->CR1 &= ~I2C_CR1_PE;
-
-  /* If in stopped state then enables the I2C and DMA clocks.*/
-  if (i2cp->state == I2C_STOP) {
-
 #if STM32_I2C_USE_DMA == TRUE
     /* Common DMA modes.*/
     i2cp->txdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_M2P;
     i2cp->rxdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_P2M;
 #endif
 
+  /* Make sure I2C peripheral is disabled */
+  dp->CR1 &= ~I2C_CR1_PE;
+
+  /* If in stopped state then enables the I2C and DMA clocks.*/
+  if (i2cp->state == I2C_STOP) {
+
 #if STM32_I2C_USE_I2C1
     if (&I2CD1 == i2cp) {
 
diff -uwr ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/RTCv1/rtc_lld.c ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/RTCv1/rtc_lld.c
--- ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/RTCv1/rtc_lld.c	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/RTCv1/rtc_lld.c	2017-04-25 11:16:44.000000000 +0300
@@ -137,7 +137,7 @@
   t = localtime_r((time_t *)&(tv_sec), &tim);
   osalDbgAssert(t != NULL, "conversion failed");
 #else
-  t = localtime(&tv_sec);
+  struct tm *t = localtime(&tv_sec);
   memcpy(&tim, t, sizeof(struct tm));
 #endif
 
diff -uwr ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/RTCv2/rtc_lld.c ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/RTCv2/rtc_lld.c
--- ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/RTCv2/rtc_lld.c	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/RTCv2/rtc_lld.c	2017-04-25 11:16:44.000000000 +0300
@@ -27,7 +27,6 @@
  */
 
 #include "hal.h"
-#include "rusefi_lse_fix.h"
 
 #if HAL_USE_RTC || defined(__DOXYGEN__)
 
@@ -76,11 +75,10 @@
  * @notapi
  */
 static void rtc_enter_init(void) {
-         int counter = 0;
+
   RTCD1.rtc->ISR |= RTC_ISR_INIT;
-  while ((RTCD1.rtc->ISR & RTC_ISR_INITF) == 0 && ++counter < LSE_TIMEOUT)
+  while ((RTCD1.rtc->ISR & RTC_ISR_INITF) == 0)
     ;
-
 }
 
 /**
@@ -349,16 +347,13 @@
   rtc_enter_init();
   rtcp->rtc->TR = tr;
   rtcp->rtc->DR = dr;
-  rtcp->rtc->CR = (rtcp->rtc->CR & ~(1U << RTC_CR_BKP_OFFSET)) |
-                  (timespec->dstflag << RTC_CR_BKP_OFFSET);
+  rtcp->rtc->CR |= timespec->dstflag << RTC_CR_BKP_OFFSET;
   rtc_exit_init();
 
   /* Leaving a reentrant critical zone.*/
   osalSysRestoreStatusX(sts);
 }
 
-extern bool rtcWorks;
-
 /**
  * @brief   Get current time.
  * @note    The function can be called from any context.
@@ -379,13 +374,10 @@
   /* Entering a reentrant critical zone.*/
   sts = osalSysGetStatusAndLockX();
 
-  int counter = 0;                                                         \
   /* Synchronization with the RTC and reading the registers, note
      DR must be read last.*/
-  while ((rtcp->rtc->ISR & RTC_ISR_RSF) == 0 && rtcWorks && ++counter <LSE_TIMEOUT)
+  while ((rtcp->rtc->ISR & RTC_ISR_RSF) == 0)
     ;
-  if (counter==LSE_TIMEOUT) {rtcWorks = false; }                           \
-
 #if STM32_RTC_HAS_SUBSECONDS
   ssr = rtcp->rtc->SSR;
 #endif /* STM32_RTC_HAS_SUBSECONDS */
diff -uwr ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/RTCv2/rtc_lld.h ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/RTCv2/rtc_lld.h
--- ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/RTCv2/rtc_lld.h	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/RTCv2/rtc_lld.h	2017-04-25 11:16:44.000000000 +0300
@@ -29,7 +29,6 @@
 #ifndef _RTC_LLD_H_
 #define _RTC_LLD_H_
 
-
 #if HAL_USE_RTC || defined(__DOXYGEN__)
 
 /*===========================================================================*/
Only in ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/RTCv2: rusefi_lse_fix.h
diff -uwr ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/SPIv1/spi_lld.c ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/SPIv1/spi_lld.c
--- ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/SPIv1/spi_lld.c	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/SPIv1/spi_lld.c	2017-04-25 11:16:44.000000000 +0300
@@ -514,8 +514,6 @@
  */
 void spi_lld_ignore(SPIDriver *spip, size_t n) {
 
-  osalDbgAssert(n < 65536, "unsupported DMA transfer size");
-
   dmaStreamSetMemory0(spip->dmarx, &dummyrx);
   dmaStreamSetTransactionSize(spip->dmarx, n);
   dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
@@ -546,8 +544,6 @@
 void spi_lld_exchange(SPIDriver *spip, size_t n,
                       const void *txbuf, void *rxbuf) {
 
-  osalDbgAssert(n < 65536, "unsupported DMA transfer size");
-
   dmaStreamSetMemory0(spip->dmarx, rxbuf);
   dmaStreamSetTransactionSize(spip->dmarx, n);
   dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);
@@ -575,8 +571,6 @@
  */
 void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {
 
-  osalDbgAssert(n < 65536, "unsupported DMA transfer size");
-
   dmaStreamSetMemory0(spip->dmarx, &dummyrx);
   dmaStreamSetTransactionSize(spip->dmarx, n);
   dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
@@ -604,8 +598,6 @@
  */
 void spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf) {
 
-  osalDbgAssert(n < 65536, "unsupported DMA transfer size");
-
   dmaStreamSetMemory0(spip->dmarx, rxbuf);
   dmaStreamSetTransactionSize(spip->dmarx, n);
   dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
diff -uwr ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/SPIv2/spi_lld.c ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/SPIv2/spi_lld.c
--- ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/SPIv2/spi_lld.c	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/SPIv2/spi_lld.c	2017-04-25 11:16:44.000000000 +0300
@@ -515,8 +515,6 @@
  */
 void spi_lld_ignore(SPIDriver *spip, size_t n) {
 
-  osalDbgAssert(n < 65536, "unsupported DMA transfer size");
-
   dmaStreamSetMemory0(spip->dmarx, &dummyrx);
   dmaStreamSetTransactionSize(spip->dmarx, n);
   dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
@@ -547,8 +545,6 @@
 void spi_lld_exchange(SPIDriver *spip, size_t n,
                       const void *txbuf, void *rxbuf) {
 
-  osalDbgAssert(n < 65536, "unsupported DMA transfer size");
-
   dmaStreamSetMemory0(spip->dmarx, rxbuf);
   dmaStreamSetTransactionSize(spip->dmarx, n);
   dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
@@ -576,8 +572,6 @@
  */
 void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {
 
-  osalDbgAssert(n < 65536, "unsupported DMA transfer size");
-
   dmaStreamSetMemory0(spip->dmarx, &dummyrx);
   dmaStreamSetTransactionSize(spip->dmarx, n);
   dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
@@ -605,8 +599,6 @@
  */
 void spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf) {
 
-  osalDbgAssert(n < 65536, "unsupported DMA transfer size");
-
   dmaStreamSetMemory0(spip->dmarx, rxbuf);
   dmaStreamSetTransactionSize(spip->dmarx, n);
   dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
diff -uwr ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/TIMv1/gpt_lld.c ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/TIMv1/gpt_lld.c
--- ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/TIMv1/gpt_lld.c	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/TIMv1/gpt_lld.c	2017-04-25 11:16:44.000000000 +0300
@@ -819,7 +819,7 @@
  */
 void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {
 
-  gptp->tim->ARR = (uint32_t)(interval);        /* Time constant.           */
+  gptp->tim->ARR   = (uint32_t)(interval - 1);  /* Time constant.           */
   gptp->tim->EGR = STM32_TIM_EGR_UG;            /* Update event.            */
   gptp->tim->CNT = 0;                           /* Reset counter.           */
 
@@ -861,7 +861,7 @@
  */
 void gpt_lld_polled_delay(GPTDriver *gptp, gptcnt_t interval) {
 
-  gptp->tim->ARR = (uint32_t)(interval);        /* Time constant.           */
+  gptp->tim->ARR  = (uint32_t)(interval - 1);   /* Time constant.           */
   gptp->tim->EGR = STM32_TIM_EGR_UG;            /* Update event.            */
   gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
   gptp->tim->CR1 = STM32_TIM_CR1_OPM | STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
diff -uwr ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/USARTv1/uart_lld.c ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/USARTv1/uart_lld.c
--- ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/USARTv1/uart_lld.c	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/USARTv1/uart_lld.c	2017-04-25 11:16:44.000000000 +0300
@@ -226,11 +226,6 @@
   /* Mustn't ever set TCIE here - if done, it causes an immediate
      interrupt.*/
   cr1 = USART_CR1_UE | USART_CR1_PEIE | USART_CR1_TE | USART_CR1_RE;
-
-  /* Add Idle interrupt if needed */
-  if (uartp->config->timeout_cb != NULL)
-  	cr1 |= USART_CR1_IDLEIE;
-
   u->CR1 = uartp->config->cr1 | cr1;
 
   /* Starting the receiver idle loop.*/
@@ -259,14 +254,7 @@
        received character and then the driver stays in the same state.*/
     _uart_rx_idle_code(uartp);
   }
-  /* DMA half-transter interrupt handling - for the 1st/2nd half transfers. */
-  else if (uartp->config->rxhalf_cb != NULL) {
-    if ((flags & STM32_DMA_ISR_HTIF) != 0) {
-    	_uart_rx_half_isr_code(uartp, 0);
-    } else if ((flags & STM32_DMA_ISR_TCIF) != 0) {
-    	_uart_rx_half_isr_code(uartp, 1);
-    }
-  } else {
+  else {
     /* Receiver in active state, a callback is generated, if enabled, after
        a completed transfer.*/
     dmaStreamDisable(uartp->dmarx);
@@ -324,11 +312,6 @@
     /* End of transmission, a callback is generated.*/
     _uart_tx2_isr_code(uartp);
   }
-
-  /* Idle interrupt sources are only checked if enabled in CR1.*/
-  if ((sr & USART_SR_IDLE) && (cr1 & USART_CR1_IDLEIE)) {
-    _uart_timeout_isr_code(uartp);
-  }
 }
 
 /*===========================================================================*/
@@ -795,14 +778,8 @@
   /* RX DMA channel preparation.*/
   dmaStreamSetMemory0(uartp->dmarx, rxbuf);
   dmaStreamSetTransactionSize(uartp->dmarx, n);
-
-  uint32_t mode = STM32_DMA_CR_DIR_P2M | STM32_DMA_CR_MINC | STM32_DMA_CR_TCIE;
-
-  /* DMA half-transfer interrupt & circular mode, if needed */
-  if (uartp->config->rxhalf_cb != NULL)
-    mode |= STM32_DMA_CR_HTIE | STM32_DMA_CR_CIRC;
-
-  dmaStreamSetMode(uartp->dmarx, uartp->dmamode | mode);
+  dmaStreamSetMode(uartp->dmarx, uartp->dmamode    | STM32_DMA_CR_DIR_P2M |
+                                 STM32_DMA_CR_MINC | STM32_DMA_CR_TCIE);
 
   /* Starting transfer.*/
   dmaStreamEnable(uartp->dmarx);
diff -uwr ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/USARTv1/uart_lld.h ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/USARTv1/uart_lld.h
--- ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/USARTv1/uart_lld.h	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/USARTv1/uart_lld.h	2017-04-25 11:16:44.000000000 +0300
@@ -461,14 +461,6 @@
 typedef void (*uartecb_t)(UARTDriver *uartp, uartflags_t e);
 
 /**
- * @brief   Receive Half-transfer UART notification callback type.
- *
- * @param[in] uartp     pointer to the @p UARTDriver object
- * @param[in] full      flag set to 1 for the second half, and 0 for the first half
- */
-typedef void (*uarthcb_t)(UARTDriver *uartp, uartflags_t full);
-
-/**
  * @brief   Driver configuration structure.
  * @note    It could be empty on some architectures.
  */
@@ -510,16 +502,6 @@
    * @brief Initialization value for the CR3 register.
    */
   uint16_t                  cr3;
-  /* Additional (optional) handlers. Placed here for the struct compatibility.*/
-  /**
-   * @brief   Receiver timeout (idle) callback.
-   * @details Handles an idle interrupt for USARTv1.
-   */
-  uartcb_t                  timeout_cb;
-  /**
-   * @brief Half-transfer receive buffer callback.
-   */
-  uarthcb_t                 rxhalf_cb;
 } UARTConfig;
 
 /**
diff -uwr ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/USARTv2/serial_lld.c ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/USARTv2/serial_lld.c
--- ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/USARTv2/serial_lld.c	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/USARTv2/serial_lld.c	2017-04-25 11:16:44.000000000 +0300
@@ -44,24 +44,15 @@
 #define USART_ISR_LBDF                      USART_ISR_LBD
 #endif
 
-/* STM32L0xx/STM32F7xx ST headers difference.*/
-#if !defined(USART_ISR_LBDF)
-#define USART_ISR_LBDF USART_ISR_LBD
-#endif
-
-/* Workarounds for those devices where UARTs are USARTs.*/
+/* Handling the case where UART4 and UART5 are actually USARTs, this happens
+   in the STM32F0xx.*/
 #if defined(USART4)
 #define UART4 USART4
 #endif
+
 #if defined(USART5)
 #define UART5 USART5
 #endif
-#if defined(USART7)
-#define UART7 USART7
-#endif
-#if defined(USART8)
-#define UART8 USART8
-#endif
 
 /*===========================================================================*/
 /* Driver exported variables.                                                */
diff -uwr ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/USARTv2/uart_lld.c ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/USARTv2/uart_lld.c
--- ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/USARTv2/uart_lld.c	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/USARTv2/uart_lld.c	2017-04-25 11:16:44.000000000 +0300
@@ -30,25 +30,6 @@
 /* Driver local definitions.                                                 */
 /*===========================================================================*/
 
-/* For compatibility for those devices without LIN support in the USARTs.*/
-#if !defined(USART_ISR_LBDF)
-#define USART_ISR_LBDF                      0
-#endif
-
-#if !defined(USART_CR2_LBDIE)
-#define USART_CR2_LBDIE                     0
-#endif
-
-/* STM32L0xx/STM32F7xx ST headers difference.*/
-#if !defined(USART_ISR_LBDF)
-#define USART_ISR_LBDF                      USART_ISR_LBD
-#endif
-
-/* STM32L0xx/STM32F7xx ST headers difference.*/
-#if !defined(USART_ISR_LBDF)
-#define USART_ISR_LBDF USART_ISR_LBD
-#endif
-
 /* STM32L0xx/STM32F7xx ST headers difference.*/
 #if !defined(USART_ISR_LBDF)
 #define USART_ISR_LBDF USART_ISR_LBD
@@ -118,25 +99,6 @@
   STM32_DMA_GETCHANNEL(STM32_UART_UART8_TX_DMA_STREAM,                      \
                        STM32_UART8_TX_DMA_CHN)
 
-/* Workarounds for those devices where UARTs are USARTs.*/
-#if defined(USART4)
-#define UART4 USART4
-#endif
-#if defined(USART5)
-#define UART5 USART5
-#endif
-#if defined(USART7)
-#define UART7 USART7
-#endif
-#if defined(USART8)
-#define UART8 USART8
-#endif
-
-/* Workaround for more differences in headers.*/
-#if !defined(USART_CR1_M0)
-#define USART_CR1_M0 USART_CR1_M
-#endif
-
 /*===========================================================================*/
 /* Driver exported variables.                                                */
 /*===========================================================================*/
@@ -777,7 +739,7 @@
 
     /* Static DMA setup, the transfer size depends on the USART settings,
        it is 16 bits if M=1 and PCE=0 else it is 8 bits.*/
-    if ((uartp->config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_M0)
+    if ((uartp->config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_M)
       uartp->dmamode |= STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
     dmaStreamSetPeripheral(uartp->dmarx, &uartp->usart->RDR);
     dmaStreamSetPeripheral(uartp->dmatx, &uartp->usart->TDR);
diff -uwr ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/USBv1/usb_lld.c ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/USBv1/usb_lld.c
--- ChibiOS-stable_rusefi/os/hal/ports/STM32/LLD/USBv1/usb_lld.c	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/os/hal/ports/STM32/LLD/USBv1/usb_lld.c	2017-04-25 11:16:44.000000000 +0300
@@ -491,7 +491,7 @@
     }
 #endif
     /* Reset procedure enforced on driver start.*/
-    usb_lld_reset(usbp);
+    _usb_reset(usbp);
   }
 }
 
diff -uwr ChibiOS-stable_rusefi/os/hal/ports/STM32/STM32F4xx/hal_lld.c ChibiOS-stable_16.1.x/os/hal/ports/STM32/STM32F4xx/hal_lld.c
--- ChibiOS-stable_rusefi/os/hal/ports/STM32/STM32F4xx/hal_lld.c	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/os/hal/ports/STM32/STM32F4xx/hal_lld.c	2017-04-25 11:16:44.000000000 +0300
@@ -23,7 +23,6 @@
  */
 
 #include "hal.h"
-#include "rusefi_lse_fix.h"
 
 /*===========================================================================*/
 /* Driver local definitions.                                                 */
@@ -64,9 +63,6 @@
     RCC->BDCR = 0;
   }
 
-  extern bool rtcWorks;
-
-
 #if STM32_LSE_ENABLED
 #if defined(STM32_LSE_BYPASS)
   /* LSE Bypass.*/
@@ -75,8 +71,7 @@
   /* No LSE Bypass.*/
   RCC->BDCR |= RCC_BDCR_LSEON;
 #endif
-  int waitCounter = 0;
-  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0 && rtcWorks && ++waitCounter <LSE_TIMEOUT)
+  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
     ;                                       /* Waits until LSE is stable.   */
 #endif
 
Only in ChibiOS-stable_rusefi/os/hal/ports/simulator: posix
diff -uwr ChibiOS-stable_rusefi/os/rt/include/chdebug.h ChibiOS-stable_16.1.x/os/rt/include/chdebug.h
--- ChibiOS-stable_rusefi/os/rt/include/chdebug.h	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/os/rt/include/chdebug.h	2017-04-25 11:16:44.000000000 +0300
@@ -121,8 +121,8 @@
 /*===========================================================================*/
 
 #if CH_DBG_SYSTEM_STATE_CHECK == TRUE
-#define _dbg_enter_lock() {(ch.dbg.lock_cnt = (cnt_t)1);  ON_LOCK_HOOK;}
-#define _dbg_leave_lock() {ON_UNLOCK_HOOK;(ch.dbg.lock_cnt = (cnt_t)0);}
+#define _dbg_enter_lock() (ch.dbg.lock_cnt = (cnt_t)1)
+#define _dbg_leave_lock() (ch.dbg.lock_cnt = (cnt_t)0)
 #endif
 
 /* When the state checker feature is disabled then the following functions
diff -uwr ChibiOS-stable_rusefi/os/rt/ports/ARM/chcore.h ChibiOS-stable_16.1.x/os/rt/ports/ARM/chcore.h
--- ChibiOS-stable_rusefi/os/rt/ports/ARM/chcore.h	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/os/rt/ports/ARM/chcore.h	2017-04-25 11:16:44.000000000 +0300
@@ -28,8 +28,6 @@
 #ifndef _CHCORE_H_
 #define _CHCORE_H_
 
-#include "chdebug.h"
-
 /*===========================================================================*/
 /* Module constants.                                                         */
 /*===========================================================================*/
@@ -290,8 +288,6 @@
 #define PORT_FAST_IRQ_HANDLER(id)                                           \
   __attribute__((interrupt("FIQ"))) void id(void)
 
-void chDbgStackOverflowPanic(thread_t *otp);
-
 /**
  * @brief   Performs a context switch between two threads.
  * @details This is the most critical code in any port, this function
@@ -309,7 +305,7 @@
 #define port_switch(ntp, otp) {                                             \
   register struct port_intctx *r13 asm ("r13");                             \
   if ((stkalign_t *)(r13 - 1) < otp->p_stklimit)                            \
-    chDbgStackOverflowPanic(otp);                                           \
+    chSysHalt("stack overflow");                                            \
   _port_switch_thumb(ntp, otp);                                             \
 }
 #else
@@ -322,7 +318,7 @@
 #define port_switch(ntp, otp) {                                             \
   register struct port_intctx *r13 asm ("r13");                             \
   if ((stkalign_t *)(r13 - 1) < otp->p_stklimit)                            \
-    chDbgStackOverflowPanic(otp);                                           \
+  chSysHalt("stack overflow");                                              \
   _port_switch_arm(ntp, otp);                                               \
 }
 #else
diff -uwr ChibiOS-stable_rusefi/os/rt/ports/SIMIA32/chcore.c ChibiOS-stable_16.1.x/os/rt/ports/SIMIA32/chcore.c
--- ChibiOS-stable_rusefi/os/rt/ports/SIMIA32/chcore.c	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/os/rt/ports/SIMIA32/chcore.c	2017-04-25 11:16:44.000000000 +0300
@@ -25,12 +25,7 @@
  * @{
  */
 
-#if defined(WIN32) 
   #include <windows.h>
-#else
-  #include <stdlib.h>
-  #include <sys/time.h>
-#endif
 
 #include "ch.h"
 
@@ -114,18 +109,11 @@
  * @return              The realtime counter value.
  */
 rtcnt_t port_rt_get_counter_value(void) {
-#if defined(WIN32)
   LARGE_INTEGER n;
 
   QueryPerformanceCounter(&n);
 
   return (rtcnt_t)(n.QuadPart / 1000LL);
-#else // POSIX
-  struct timeval tv;
-
-  gettimeofday(&tv, NULL);
-  return (rtcnt_t)(tv.tv_usec);
-#endif
 }
 
 /** @} */
diff -uwr ChibiOS-stable_rusefi/os/rt/src/chdebug.c ChibiOS-stable_16.1.x/os/rt/src/chdebug.c
--- ChibiOS-stable_rusefi/os/rt/src/chdebug.c	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/os/rt/src/chdebug.c	2017-04-25 11:16:44.000000000 +0300
@@ -85,8 +85,6 @@
 /* Module local definitions.                                                 */
 /*===========================================================================*/
 
-extern int maxNesting;
-
 /*===========================================================================*/
 /* Module exported variables.                                                */
 /*===========================================================================*/
@@ -152,7 +150,7 @@
 void _dbg_check_lock(void) {
 
   if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
-    chSysHalt("SV#4 misplaced chSysLock()");
+    chSysHalt("SV#4");
   }
   _dbg_enter_lock();
 }
@@ -178,7 +176,7 @@
 void _dbg_check_lock_from_isr(void) {
 
   if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
-    chSysHalt("SV#6 misplaced chSysLockFromISR()");
+    chSysHalt("SV#6");
   }
   _dbg_enter_lock();
 }
@@ -208,8 +206,6 @@
     chSysHalt("SV#8");
   }
   ch.dbg.isr_cnt++;
-  if (ch.dbg.isr_cnt > maxNesting)
-          maxNesting = ch.dbg.isr_cnt;
   port_unlock_from_isr();
 }
 
@@ -239,7 +235,7 @@
 void chDbgCheckClassI(void) {
 
   if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
-    chSysHalt("SV#10 misplaced I-class function");
+    chSysHalt("SV#10");
   }
 }
 
diff -uwr ChibiOS-stable_rusefi/testhal/STM32/STM32F3xx/EXT/main.c ChibiOS-stable_16.1.x/testhal/STM32/STM32F3xx/EXT/main.c
--- ChibiOS-stable_rusefi/testhal/STM32/STM32F3xx/EXT/main.c	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/testhal/STM32/STM32F3xx/EXT/main.c	2017-04-25 11:16:44.000000000 +0300
@@ -65,17 +65,6 @@
     {EXT_CH_MODE_DISABLED, NULL},
     {EXT_CH_MODE_DISABLED, NULL},
     {EXT_CH_MODE_DISABLED, NULL},
-    {EXT_CH_MODE_DISABLED, NULL},
-    {EXT_CH_MODE_DISABLED, NULL},
-    {EXT_CH_MODE_DISABLED, NULL},
-    {EXT_CH_MODE_DISABLED, NULL},
-    {EXT_CH_MODE_DISABLED, NULL},
-    {EXT_CH_MODE_DISABLED, NULL},
-    {EXT_CH_MODE_DISABLED, NULL},
-    {EXT_CH_MODE_DISABLED, NULL},
-    {EXT_CH_MODE_DISABLED, NULL},
-    {EXT_CH_MODE_DISABLED, NULL},
-    {EXT_CH_MODE_DISABLED, NULL},
     {EXT_CH_MODE_DISABLED, NULL}
   }
 };
diff -uwr ChibiOS-stable_rusefi/testhal/STM32/STM32L4xx/GPT-ADC/main.c ChibiOS-stable_16.1.x/testhal/STM32/STM32L4xx/GPT-ADC/main.c
--- ChibiOS-stable_rusefi/testhal/STM32/STM32L4xx/GPT-ADC/main.c	2017-11-22 03:15:55.000000000 +0200
+++ ChibiOS-stable_16.1.x/testhal/STM32/STM32L4xx/GPT-ADC/main.c	2017-04-25 11:16:44.000000000 +0300
@@ -68,24 +68,23 @@
 
 /*
  * ADC conversion group.
- * Mode:        Continuous, 16 samples of 2 channels, HW triggered by
+ * Mode:        Continuous, 16 samples of 2 channels, HS triggered by
  *              GPT4-TRGO.
- * Channels:    VRef, PA0.
+ * Channels:    VRef, PC1.
  */
 static const ADCConversionGroup adcgrpcfg1 = {
   true,
   ADC_GRP1_NUM_CHANNELS,
   adccallback,
   adcerrorcallback,
-  ADC_CFGR_EXTEN_RISING | ADC_CFGR_EXTSEL_SRC(12),                 /* CFGR   */
+  ADC_CFGR_CONT | ADC_CFGR_EXTEN_RISING | ADC_CFGR_EXTSEL_SRC(12), /* CFGR   */
   ADC_TR(0, 4095),                                                 /* TR1    */
   {                                                                /* SMPR[2]*/
-    ADC_SMPR1_SMP_AN0(ADC_SMPR_SMP_247P5) |
-    ADC_SMPR1_SMP_AN5(ADC_SMPR_SMP_247P5),
-    0
+    ADC_SMPR1_SMP_AN0(ADC_SMPR_SMP_247P5),
+    ADC_SMPR1_SMP_AN2(ADC_SMPR_SMP_247P5)
   },
   {                                                                /* SQR[4] */
-    ADC_SQR1_SQ1_N(ADC_CHANNEL_IN0) | ADC_SQR1_SQ2_N(ADC_CHANNEL_IN5),
+    ADC_SQR1_SQ1_N(ADC_CHANNEL_IN0) | ADC_SQR1_SQ2_N(ADC_CHANNEL_IN2),
     0,
     0,
     0
@@ -146,11 +145,9 @@
   adcSTM32EnableVREF(&ADCD1);
   adcSTM32EnableTS(&ADCD1);
 
-  palSetLineMode(LINE_ARD_A0, PAL_MODE_INPUT_ANALOG);
-
   /*
    * Starts an ADC continuous conversion triggered with a period of
-   * 1/10000 second.
+   * 1/1000000 second.
    */
   adcStartConversion(&ADCD1, &adcgrpcfg1, samples1, ADC_GRP1_BUF_DEPTH);
   gptStartContinuous(&GPTD4, 100);
